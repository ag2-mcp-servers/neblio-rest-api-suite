# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T07:10:48+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel


class Error(BaseModel):
    code: Optional[int] = None
    fields: Optional[str] = None
    message: Optional[str] = None


class BroadcastTxRequest(BaseModel):
    txHex: str = Field(..., description='Signed raw tx hex to broadcast')


class BroadcastTxResponse(BaseModel):
    txid: Optional[str] = Field(
        None, description='Txid of successfully broadcasted transaction'
    )


class BurnItem(BaseModel):
    amount: Optional[float] = Field(None, description='Amount of tokens to burn')
    tokenId: Optional[str] = Field(None, description='Unique token id we are burning')


class TransferItem(BaseModel):
    address: Optional[str] = Field(None, description='Address to transfer tokens to')
    amount: Optional[float] = Field(None, description='Number of tokens to send')
    tokenId: Optional[str] = Field(None, description='ID of token we are sending')


class BurnTokenRequest(BaseModel):
    burn: List[BurnItem] = Field(
        ..., description='Array of objects representing tokens to be burned'
    )
    fee: float = Field(
        ...,
        description='Fee in satoshi to include in the issuance transaction min 10000 (0.0001 NEBL)',
    )
    from_: Optional[List[str]] = Field(
        None, alias='from', description='Array of addresses to send the token from'
    )
    transfer: Optional[List[TransferItem]] = None


class BurnTokenResponse(BaseModel):
    multisigOutputs: Optional[List[float]] = Field(
        None, description='Array of indexes of multisig outputs'
    )
    ntp1OutputIndexes: Optional[List[float]] = Field(
        None, description='Array of indexes transfering NTP1 tokens'
    )
    txHex: Optional[str] = Field(
        None,
        description='Unsigned, raw transaction hex of the transaction to burn the token',
    )


class GetAddressBalanceResponse(RootModel[float]):
    root: float = Field(..., description='Address balance in satoshis')


class Token(BaseModel):
    aggregationPolicy: Optional[str] = Field(
        None, description='Whether the tokens can be aggregated together'
    )
    amount: Optional[float] = Field(None, description='Number of Tokens')
    divisibility: Optional[float] = Field(
        None, description='Decimal places the token is divisible to'
    )
    issueTxid: Optional[str] = Field(
        None, description='TXID the token originally was issued in'
    )
    lockStatus: Optional[bool] = Field(
        None,
        description='Whether the token is locked, preventing more from being issued',
    )
    tokenId: Optional[str] = Field(
        None, description='Unique NTP1 identifier for this token'
    )


class Utxo(BaseModel):
    blockheight: Optional[float] = Field(None, description='Blockheight of the UTXO')
    blocktime: Optional[float] = Field(None, description='Blocktime of the UTXO')
    index: Optional[float] = Field(
        None, description='Index of the UTXO at this address'
    )
    scriptPubKey: Optional[Dict[str, Any]] = Field(
        None, description='Object representing the scruptPubKey of the UTXO'
    )
    tokens: Optional[List[Token]] = Field(
        None, description='Array of NTP1 tokens in this UTXO.'
    )
    txid: Optional[str] = Field(None, description='Txid of this UTXO')
    used: Optional[bool] = Field(None, description='Whether the UTXO has been used')
    value: Optional[float] = Field(
        None, description='Value of the UTXO in NEBL satoshi'
    )


class GetAddressInfoResponse(BaseModel):
    address: Optional[str] = Field(None, description='The Neblio Address')
    utxos: Optional[List[Utxo]] = Field(
        None, description='Array of UTXOs held at this address.'
    )


class GetAddressResponse(BaseModel):
    addrStr: Optional[str] = Field(None, description='Address in string form')
    balance: Optional[float] = Field(None, description='NEBL balance')
    balanceSat: Optional[float] = Field(None, description='NEBL balance in satoshis')
    totalReceived: Optional[float] = Field(None, description='Total NEBL received')
    totalReceivedSat: Optional[float] = Field(
        None, description='Total NEBL received in satoshis'
    )
    totalSent: Optional[float] = Field(None, description='Total NEBL sent')
    totalSentSat: Optional[float] = Field(None, description='Total NEBL sent satoshis')
    transactions: Optional[List[str]] = Field(
        None, description='Array of transaction ids for this address'
    )
    txAppearances: Optional[float] = Field(
        None, description='Number of transactions for this address'
    )
    unconfirmedBalance: Optional[float] = Field(
        None, description='Unconfirmed NEBL balance'
    )
    unconfirmedBalanceSat: Optional[float] = Field(
        None, description='Unconfirmed NEBL balance in satoshis'
    )
    unconfirmedTxAppearances: Optional[float] = Field(
        None, description='Number of unconfirmed transactions for this address'
    )


class GetAddressTotalReceivedResponse(RootModel[float]):
    root: float = Field(..., description='Address total received in satoshis')


class GetAddressTotalSentResponse(RootModel[float]):
    root: float = Field(..., description='Address total sent in satoshis')


class GetAddressUnconfirmedBalanceResponse(RootModel[float]):
    root: float = Field(..., description='Address unconfirmed balance in satoshis')


class GetAddressUtxosResponseItem(BaseModel):
    address: Optional[str] = Field(None, description='Address')
    amount: Optional[float] = Field(None, description='NEBL amount')
    confirmations: Optional[float] = Field(None, description='Number of confirmations')
    scriptPubKey: Optional[str] = Field(None, description='scriptPubKey')
    ts: Optional[float] = Field(None, description='Timestamp')
    txid: Optional[str] = Field(None, description='Transaction ID')
    vout: Optional[float] = Field(None, description='vout')


class GetAddressUtxosResponse(RootModel[List[GetAddressUtxosResponseItem]]):
    root: List[GetAddressUtxosResponseItem] = Field(
        ..., description="Array of objects representing this address' UTXOs"
    )


class GetBlockIndexResponse(BaseModel):
    blockHash: Optional[str] = Field(None, description='Hash of the requested block')


class GetBlockResponse(BaseModel):
    bits: Optional[str] = Field(None, description='Block bits')
    confirmations: Optional[float] = Field(
        None, description='Number of confirmations block has'
    )
    difficulty: Optional[float] = Field(None, description='Block difficulty')
    hash: Optional[str] = Field(None, description='Block hash')
    height: Optional[float] = Field(None, description='Block height')
    merkleroot: Optional[str] = Field(None, description='Merkleroot of block')
    nextblockhash: Optional[str] = Field(
        None, description='Hash of the next block on the chain'
    )
    nonce: Optional[float] = Field(None, description='Block nonce')
    previousblockhash: Optional[str] = Field(
        None, description='Hash of the previous block on the chain'
    )
    reward: Optional[float] = Field(
        None, description='Number of NEBL awarded in this block'
    )
    size: Optional[float] = Field(None, description='Block size in bytes')
    time: Optional[float] = Field(None, description='Block time relative to epoch')
    tx: Optional[List[str]] = Field(None, description='Array of tx ids in the block')
    version: Optional[float] = Field(None, description='Block version')


class Data(BaseModel):
    txId: Optional[str] = Field(None, description='TXID of a successful withdrawal')


class GetFaucetResponse(BaseModel):
    data: Optional[Data] = None
    status: Optional[str] = Field(
        None, description='Whether the withdrawal was successful'
    )


class GetRawTxResponse(BaseModel):
    rawtx: Optional[str] = Field(
        None, description='Raw hex representing the transaction'
    )


class GetStatusResponse(BaseModel):
    pass


class GetSyncResponse(BaseModel):
    blockChainHeight: Optional[float] = Field(
        None, description='Current blockchain height'
    )
    error: Optional[str] = Field(None, description='Recent sync error messages')
    height: Optional[float] = Field(None, description='Height node is synced to')
    status: Optional[str] = Field(None, description='Current sync status')
    syncPercentage: Optional[float] = Field(None, description='Current sync percentage')
    type: Optional[str] = Field(None, description='Node type')


class Holder(BaseModel):
    address: Optional[str] = None
    amount: Optional[float] = None


class GetTokenHoldersResponse(BaseModel):
    aggregationPolicy: Optional[str] = Field(
        None, description='Whether the tokesn are aggregatable'
    )
    divibility: Optional[float] = Field(
        None, description='How many decimal points the token is divisble to'
    )
    holders: Optional[List[Holder]] = None
    lockStatus: Optional[bool] = Field(
        None, description='Whether new issuances of this token are locked'
    )
    someUtxo: Optional[str] = Field(None, description='A UTXO of this token')
    tokenId: Optional[str] = Field(None, description='TokenId of the token')


class GetTokenIdResponse(BaseModel):
    tokenId: Optional[str] = Field(None, description='Unique ID of the token')
    tokenName: Optional[str] = Field(
        None, description='String representing the token Symbol'
    )


class MetaItem(BaseModel):
    key: Optional[str] = None
    value: Optional[str] = None


class UserData(BaseModel):
    meta: Optional[List[MetaItem]] = None


class Data1(BaseModel):
    description: Optional[str] = Field(None, description='Token description')
    issuer: Optional[str] = Field(None, description='Name of token issuer')
    tokenName: Optional[str] = Field(None, description='Token symbol')
    userData: Optional[UserData] = Field(
        None, description='Metadata set by user on token'
    )


class MetadataOfIssuance(BaseModel):
    data: Optional[Data1] = None


class UserData1(BaseModel):
    meta: Optional[List[Dict[str, Any]]] = None


class MetadataOfUtxo(BaseModel):
    userData: Optional[UserData1] = Field(
        None, description='Metadata set by user on token for UTXO'
    )


class GetTokenMetadataResponse(BaseModel):
    aggregationPolicy: Optional[str] = Field(
        None, description='Whether the tokens are aggregatable'
    )
    divisibility: Optional[float] = Field(
        None, description='Decimal places the token is divisible to'
    )
    firstBlock: Optional[float] = Field(
        None, description='Block number token was issued in'
    )
    initialIssuanceAmount: Optional[float] = Field(
        None, description='Total tokens issued in initial issuance'
    )
    issuanceTxid: Optional[str] = Field(
        None, description='TXID the token was issued with'
    )
    issueAddress: Optional[str] = Field(
        None, description='Address that issued the tokens'
    )
    lockStatus: Optional[bool] = Field(
        None, description='Whether issuance of more tokens is locked'
    )
    metadataOfIssuance: Optional[MetadataOfIssuance] = Field(
        None, description='Metadata set at issuance'
    )
    metadataOfUtxo: Optional[MetadataOfUtxo] = Field(
        None, description='Metadata set for UTXO'
    )
    numOfBurns: Optional[float] = Field(
        None, description='Number of times tokens have been burned'
    )
    numOfHolders: Optional[float] = Field(
        None, description='Total number of addresses this token is held at'
    )
    numOfIssuance: Optional[float] = Field(
        None, description='Total number of times this token has been issued'
    )
    numOfTransfers: Optional[float] = Field(
        None, description='Total number of transactions of this token'
    )
    someUtxo: Optional[str] = Field(
        None, description='Example UTXO containing this token.'
    )
    tokenId: Optional[str] = Field(None, description='ID of the token')
    totalSupply: Optional[float] = Field(
        None, description='Total number of tokens in supply'
    )


class PreviousOutput(BaseModel):
    addresses: Optional[List[str]] = None
    asm: Optional[str] = None
    hex: Optional[str] = None
    reqSigs: Optional[float] = None
    type: Optional[str] = None


class ScriptSig(BaseModel):
    asm: Optional[str] = None
    hex: Optional[str] = None


class Token1(BaseModel):
    aggregationPolicy: Optional[str] = Field(
        None, description='Whether the tokens are aggregatable'
    )
    amount: Optional[float] = Field(None, description='Number of tokens')
    divisibility: Optional[float] = Field(
        None, description='Decimal places the token is divisible to'
    )
    issueTxid: Optional[str] = Field(None, description='TXID the token was issued in')
    lockStatus: Optional[bool] = Field(
        None, description='Whether issuance of more tokens is locked'
    )
    tokenId: Optional[str] = Field(None, description='ID of the token')


class VinItem(BaseModel):
    previousOutput: Optional[PreviousOutput] = None
    scriptSig: Optional[ScriptSig] = None
    sequence: Optional[float] = None
    tokens: Optional[List[Token1]] = None
    txid: Optional[str] = Field(None, description='TXID of the input')
    value: Optional[float] = Field(None, description='Value of input in NEBL satoshi')
    vout: Optional[float] = Field(None, description='output index')


class ScriptPubKey(BaseModel):
    addresses: Optional[List[str]] = None
    asm: Optional[str] = None
    hex: Optional[str] = None
    reqSigs: Optional[float] = None
    type: Optional[str] = None


class VoutItem(BaseModel):
    blockheight: Optional[float] = Field(
        None, description='Blockheight of this transaction'
    )
    n: Optional[float] = Field(None, description='Output index')
    scriptPubKey: Optional[ScriptPubKey] = None
    tokens: Optional[List[Token1]] = None
    used: Optional[bool] = Field(
        None, description='Whether this output has now been used'
    )
    usedBlockheight: Optional[float] = Field(
        None, description='Blockheight this output was used in'
    )
    usedTxid: Optional[str] = Field(None, description='TXID this output was used in')
    value: Optional[float] = Field(
        None, description='Value of the output in NEBL satoshi'
    )


class GetTransactionInfoResponse(BaseModel):
    blockhash: Optional[str] = Field(
        None, description='Hash of the block this transaction is in'
    )
    blockheight: Optional[float] = Field(
        None, description='Block height of this transaction'
    )
    blocktime: Optional[float] = Field(
        None, description='Block time of this transaction'
    )
    confirmations: Optional[float] = Field(
        None, description='Number of transaction confirmations'
    )
    fee: Optional[float] = Field(
        None, description='Total NEBL used as fee for this transcation in satoshis'
    )
    hex: Optional[str] = Field(None, description='Transaction in raw hex')
    locktime: Optional[float] = Field(None, description='Transaction locktime')
    time: Optional[float] = Field(None, description='Transaction time')
    totalsent: Optional[float] = Field(
        None, description='Total NEBL sent in this transaction in satoshis'
    )
    txid: Optional[str] = Field(None, description='TXID of transaction')
    version: Optional[float] = Field(None, description='Transaction version')
    vin: Optional[List[VinItem]] = Field(
        None, description='Array of transaction inputs'
    )
    vout: Optional[List[VoutItem]] = Field(
        None, description='Array of transaction outputs'
    )


class VinItem1(BaseModel):
    n: Optional[float] = Field(None, description='input index')
    scriptSig: Optional[ScriptSig] = None
    sequence: Optional[float] = None
    txid: Optional[str] = Field(None, description='TXID of the input')
    value: Optional[float] = Field(None, description='Value of input in NEBL')
    valueSat: Optional[float] = Field(
        None, description='Value of input in NEBL satoshi'
    )
    vout: Optional[float] = Field(None, description='output index')


class VoutItem1(BaseModel):
    blockheight: Optional[float] = Field(
        None, description='Blockheight of this transaction'
    )
    n: Optional[float] = Field(None, description='Output index')
    scriptPubKey: Optional[ScriptPubKey] = None
    used: Optional[bool] = Field(
        None, description='Whether this output has now been used'
    )
    usedBlockheight: Optional[float] = Field(
        None, description='Blockheight this output was used in'
    )
    usedTxid: Optional[str] = Field(None, description='TXID this output was used in')
    value: Optional[float] = Field(None, description='Value of the output in NEBL')


class GetTxResponse(BaseModel):
    blockhash: Optional[str] = Field(
        None, description='Hash of the block this transaction is in'
    )
    blockheight: Optional[float] = Field(
        None, description='Block height of this transaction'
    )
    blocktime: Optional[float] = Field(
        None, description='Block time of this transaction'
    )
    confirmations: Optional[float] = Field(
        None, description='Number of transaction confirmations'
    )
    fee: Optional[float] = Field(
        None, description='Total NEBL used as fee for this transcation in satoshis'
    )
    fees: Optional[float] = Field(
        None, description='Total NEBL used in fees for this transaction'
    )
    locktime: Optional[float] = Field(None, description='Transaction locktime')
    size: Optional[float] = Field(None, description='Transcation size in bytes')
    time: Optional[float] = Field(None, description='Transaction time')
    totalsent: Optional[float] = Field(
        None, description='Total NEBL sent in this transaction in satoshis'
    )
    txid: Optional[str] = Field(None, description='TXID of transaction')
    valueIn: Optional[float] = Field(
        None, description='Total NEBL input in this transaction'
    )
    valueOut: Optional[float] = Field(
        None, description='Total NEBL output in this transaction'
    )
    version: Optional[float] = Field(None, description='Transaction version')
    vin: Optional[List[VinItem1]] = Field(
        None, description='Array of transaction inputs'
    )
    vout: Optional[List[VoutItem1]] = Field(
        None, description='Array of transaction outputs'
    )


class GetTxsResponse(BaseModel):
    pagesTotal: Optional[float] = Field(
        None, description='Number of pages of transactions'
    )
    txs: Optional[List[GetTxResponse]] = Field(
        None, description='Array of transaction objects'
    )


class Flags(BaseModel):
    splitChange: Optional[bool] = Field(
        None,
        description='If true change will be split into 2 outputs, one for NEBL change and one for NTP1 change (recommended)',
    )


class Encryption(BaseModel):
    format: Optional[str] = Field(None, description='key format (pem or der)')
    key: Optional[str] = Field(None, description='userData key to encrypt')
    pubkey: Optional[str] = Field(
        None, description='RSA public key used for encryption'
    )
    type: Optional[str] = Field(None, description='pkcs1 or pkcs8')


class Expiration(BaseModel):
    locked: Optional[bool] = Field(
        None, description='Whether this rule can be modified in future transactions'
    )
    validUntil: Optional[float] = Field(None, description='Blockheight at wh')


class Item(BaseModel):
    address: Optional[str] = Field(None, description='Address fee is auto sent to')
    tokenId: Optional[str] = Field(
        None,
        description='How fee should be paid, either with a tokenId, or with NEBL if null',
    )
    value: Optional[str] = Field(
        None, description='Amount of NTP1 token, or NEBL (in satoshi) to pay as fee'
    )


class Fees(BaseModel):
    items: Optional[List[Item]] = Field(
        None, description='Array of objects describing fee rules'
    )
    locked: Optional[bool] = Field(
        None, description='Whether this rule can be modified in future transactions'
    )


class Holder1(BaseModel):
    address: Optional[str] = Field(None, description='Address that can hold the token')
    locked: Optional[bool] = Field(
        None, description='Whether this rule can be modified in future transactions'
    )


class Rules(BaseModel):
    expiration: Optional[Expiration] = Field(
        None, description='Object describing expiration rules of the token'
    )
    fees: Optional[Fees] = None
    holders: Optional[List[Holder1]] = Field(
        None,
        description='Array of objects describing what addresses can hold the token',
    )


class Url(BaseModel):
    dataHash: Optional[str] = Field(
        None, description='Hash of data at the URL, used for verification'
    )
    mimeType: Optional[str] = Field(None, description='mimeType of URL content')
    name: Optional[str] = Field(None, description='Name of the URL')
    url: Optional[str] = Field(None, description='Actual URL')


class UserData2(BaseModel):
    meta: Optional[List[MetaItem]] = None


class Metadata(BaseModel):
    description: Optional[str] = Field(
        None, description='Long name or description of token (ex. Nibble)'
    )
    encryptions: Optional[List[Encryption]] = Field(
        None,
        description='Array of encryption instruction objects for encrypting userData',
    )
    issuer: Optional[str] = Field(None, description='Name of token issuer')
    rules: Optional[Rules] = Field(None, description='Object describing token rules')
    tokenName: Optional[str] = Field(
        None, description='Token Symbol it will be identified by (ex. NIBBL)'
    )
    urls: Optional[List[Url]] = None
    userData: Optional[UserData2] = Field(
        None, description='Metadata set by user on token'
    )


class TransferItem1(BaseModel):
    address: Optional[str] = Field(
        None, description='Address to send the amount of issued tokens to'
    )
    amount: Optional[float] = None


class IssueTokenRequest(BaseModel):
    amount: float = Field(..., description='Number of tokens to issue')
    divisibility: float = Field(
        ...,
        description='Number of decimal places the token should be divisble by (0-7)',
    )
    fee: float = Field(
        ...,
        description='Fee in satoshi to include in the issuance transaction min 1000000000 (10 NEBL)',
    )
    flags: Optional[Flags] = Field(
        None,
        description='Object representing flags that potentialy modify this transaction',
    )
    issueAddress: str = Field(..., description='Address issuing the token')
    metadata: Optional[Metadata] = Field(
        None, description='Object representing all metadata at token issuance'
    )
    reissuable: bool = Field(..., description='whether the token should be reissuable')
    transfer: List[TransferItem1]


class IssueTokenResponse(BaseModel):
    tokenId: Optional[str] = Field(
        None, description='TokenId of the to be issued token'
    )
    txHex: Optional[str] = Field(
        None,
        description='Unsigned, raw transaction hex of the transaction to issue the token',
    )


class RpcRequest(BaseModel):
    id: str = Field(
        ..., description='Identifier of RCP caller', examples=['neblio-apis']
    )
    jsonrpc: str = Field(..., description='JSON-RPC version', examples=['1.0'])
    method: str = Field(
        ...,
        description='Name of the Neblio RPC method to call',
        examples=['getstakinginfo'],
    )
    params: List[str] = Field(
        ...,
        description='Array of string params that should be passed to the RPC method.',
        examples=[[]],
    )


class RpcResponse(BaseModel):
    error: Optional[Dict[str, Any]] = Field(
        None, description='Object containing any error information.'
    )
    id: Optional[str] = Field(None, description='Identifier of RCP caller')
    result: Optional[Dict[str, Any]] = Field(
        None, description='Object containing the response output.'
    )


class Fees1(BaseModel):
    items: Optional[List[Item]] = Field(
        None, description='Array of objects describing fee rules'
    )
    locked: Optional[bool] = Field(
        None, description='Whether this rule can be modified in future transactions'
    )


class Rules1(BaseModel):
    expiration: Optional[Expiration] = Field(
        None, description='Object describing expiration rules of the token'
    )
    fees: Optional[Fees1] = None
    holders: Optional[List[Holder1]] = Field(
        None,
        description='Array of objects describing what addresses can hold the token',
    )


class UserData3(BaseModel):
    meta: Optional[List[MetaItem]] = None


class Metadata1(BaseModel):
    description: Optional[str] = Field(
        None, description='Long name or description of token (ex. Nibble)'
    )
    encryptions: Optional[List[Encryption]] = Field(
        None,
        description='Array of encryption instruction objects for encrypting userData',
    )
    issuer: Optional[str] = Field(None, description='Name of token issuer')
    rules: Optional[Rules1] = Field(None, description='Object describing token rules')
    tokenName: Optional[str] = Field(
        None, description='Token Symbol it will be identified by (ex. NIBBL)'
    )
    urls: Optional[List[Url]] = None
    userData: Optional[UserData3] = Field(
        None, description='Metadata set by user on token'
    )


class ToItem(BaseModel):
    address: Optional[str] = Field(None, description='Address to transfer tokens to')
    amount: Optional[float] = Field(None, description='Number of tokens to send')
    tokenId: Optional[str] = Field(None, description='ID of token we are sending')


class SendTokenRequest(BaseModel):
    fee: float = Field(
        ...,
        description='Fee in satoshi to include in the issuance transaction min 10000 (0.0001 NEBL)',
    )
    flags: Optional[Flags] = Field(
        None,
        description='Object representing flags that potentialy modify this transaction',
    )
    from_: Optional[List[str]] = Field(
        None, alias='from', description='Array of addresses to send the token from'
    )
    metadata: Optional[Metadata1] = Field(
        None, description='Object representing all metadata at token issuance'
    )
    sendutxo: Optional[List[str]] = Field(
        None, description='Array of UTXOs to send the token from'
    )
    to: List[ToItem]


class SendTokenResponse(BaseModel):
    multisigOutputs: Optional[List[float]] = Field(
        None, description='Array of indexes of multisig outputs'
    )
    ntp1OutputIndexes: Optional[List[float]] = Field(
        None, description='Array of indexes transfering NTP1 tokens'
    )
    txHex: Optional[str] = Field(
        None,
        description='Unsigned, raw transaction hex of the transaction to send the token',
    )


class SendTxRequest(BaseModel):
    rawtx: str = Field(..., description='Signed raw tx hex to broadcast')
